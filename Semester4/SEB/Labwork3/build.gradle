plugins {
    id 'java'
    id 'war'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.hibernate.orm:hibernate-core:6.3.1.Final'
    implementation 'org.glassfish.jaxb:jaxb-runtime:4.0.3'
    implementation 'com.auth0:java-jwt:4.4.0'
    implementation 'ch.qos.logback:logback-classic:1.3.12'
    implementation 'at.favre.lib:bcrypt:0.10.2'
    implementation 'org.apache.commons:commons-lang3:3.14.0'
    implementation 'org.eclipse.angus:jakarta.mail:1.0.0'
    implementation 'software.amazon.awssdk:s3:2.29.29'
    implementation 'jakarta.platform:jakarta.jakartaee-api:10.0.0'
    implementation 'jakarta.mail:jakarta.mail-api:2.1.0'

    compileOnly     'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
}

group = 'ru.rmntim.web'
version = project.version
description = 'javaee-backend'

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

tasks.withType(JavaCompile) {
    options.encoding = project.findProperty('encoding') ?: 'UTF-8'
}
tasks.withType(Javadoc) {
    options.encoding = project.findProperty('encoding') ?: 'UTF-8'
}

war {
    archiveFileName.set('ROOT.war')
    manifest {
        attributes(
            'Implementation-Version': project.version,
        )
    }
}

def envsProp = project.findProperty('envs') ?: ''
ext.envs = envsProp.split(',')
    .findAll()
    .collectEntries { entry ->
        def parts = entry.split(':')
        def name = parts[0]
        def javaHome = parts[1]
        def vmArgs = parts.size() > 2 ? parts[2].split(';') : []
        [ (name) : [ javaHome: javaHome, vmArgs: vmArgs ] ]
    }

def rp = project.findProperty('replacePatterns') ?: ''
ext.replacePatterns = rp.split(',')
    .findAll()
    .collectEntries { entry ->
        def (oldTok, newTok) = entry.split(':')
        [ (oldTok) : newTok ]
    }

ext.diffIgnoreClasses = project.findProperty('diffIgnoreClasses')
    ?.split(',') ?: []

// ----------------
// 1) xml – валидация
// ----------------
task xml {
    group       = 'verification'
    description = 'Validate all XML files.'
    doLast {
        fileTree('src').include('**/*.xml').each { f ->
            ant.xmlvalidate(file: f)
            println "Validated XML: $f"
        }
    }
}

// ------------------------
// 2) scp – копирование WAR
// ------------------------
task scp(type: Exec) {
  group     = 'deployment'
  dependsOn = [war]
  description = 'Copy WAR to remote host via system scp.'

  // если у вас нестандартный ключ, можно передать -i "$scpKeyFile"
  commandLine = [
    'scp',
    '-i', project.findProperty('scpKeyFile') ?: '',
    war.archiveFile.get().asFile.absolutePath,
    "${project.scpUser}@${project.scpHost}:${project.scpRemotePath}"
  ].findAll { it }  // убираем пустые элементы
}

// ------------------------------------------
// 3) native2ascii – конверсия .properties
// ------------------------------------------
task native2ascii {
  group       = 'translation'
  description = 'Convert all .properties via native2ascii in one go.'
  
  // создаём папку при необходимости
  doFirst { file("$buildDir/ascii").mkdirs() }
  
  // ant.native2ascii умеет брать srcdir/destdir с includes
  doLast {
    ant.native2ascii(
      src  : 'src/main/resources',
      dest : "$buildDir/ascii",
      encoding: project.encoding
    )
    println "All .properties converted into $buildDir/ascii"
  }
}


// ----------------------------
// 5) music – проиграть музыку
// ----------------------------
task music {
    group       = 'misc'
    description = 'Play music after build.'
    dependsOn   build
    doLast {
        ant.exec(executable: project.findProperty('musicPlayer')) {
            arg(value: project.findProperty('musicFile'))
        }
        println 'Music played.'
    }
}

// --------------------------------------------------
// 6) env – сборка и запуск в альтернативных средах
// --------------------------------------------------
task env {
  group       = 'verification'
  description = 'Run WAR in configured alternative environments.'
  dependsOn   war

  doLast {
    envs.each { name, cfg ->
      println "=== ENV: $name ==="
      project.javaexec { spec ->
        // 1) path to java
        spec.executable = "${cfg.javaHome}/bin/java"
        // 2) THIS is how you pass JVM args:
        spec.jvmArgs(cfg.vmArgs)
        // 3) run as “-jar ROOT.war” or via classpath + main:
        //    either:
        spec.args(['-jar', war.archiveFile.get().asFile])
      }
    }
  }
}


// ----------------------------------------------------------------
// 7) team – собрать N предыдущих ревизий, запаковать их JAR-ы в ZIP
// ----------------------------------------------------------------
task team {
    group       = 'build'
    description = 'Build last N Git revisions and zip their WARs.'
    doLast {
        def tmp     = file("$buildDir/team")
        def warsDir = file("$buildDir/team/wars")
        tmp.mkdirs(); warsDir.mkdirs()

        def revsOut = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-list', '-n',
                        project.findProperty('teamRevisionsCount'),
                        'HEAD'
            standardOutput = revsOut
        }
        def revs = revsOut.toString().trim().split('\n')

        revs.each { rev ->
            def dir = file("$tmp/$rev")
            exec { commandLine 'git', 'clone', '.', dir.absolutePath }
            exec { workingDir dir; commandLine 'git', 'checkout', rev }
            exec {
                workingDir dir
                commandLine './gradlew', 'clean', 'build'
            }
            copy {
                from("$dir/build/libs/${war.archiveFile.get().asFile.name}")
                into warsDir
                rename { "${project.name}-${rev}.war" }
            }
        }

        def outZip = file("$buildDir/${project.name}-team.zip")
        ant.zip(destfile: outZip) {
            fileset(dir: "$buildDir/team/wars")
        }
        println 'Team archive created.'
    }
}

// -----------------------------------------------------
// 8) alt – альтернативная версия: replace + упаковать JAR
// -----------------------------------------------------
task prepareAlt {
    group       = 'build'
    description = 'Prepare alt sources with replacements.'
    doLast {
        def src    = file('src/main/java')
        def altSrc = file("$buildDir/alt-sources")
        copy { from src; into altSrc }
        replacePatterns.each { oldTok, newTok ->
            ant.replace(dir: altSrc, token: oldTok, value: newTok)
        }
        println 'Alt sources prepared.'
    }
}

task compileAlt(type: JavaCompile) {
    dependsOn      prepareAlt
    source         = fileTree("$buildDir/alt-sources") { include '**/*.java' }
    classpath      = sourceSets.main.compileClasspath
    destinationDir = file("$buildDir/alt-classes")
    options.encoding = project.findProperty('encoding') ?: 'UTF-8'

    // THIS is the magic line: point at your annotation-processor classpath
    options.annotationProcessorPath = configurations.annotationProcessor
}

task altJar(type: Jar) {
    dependsOn       compileAlt
    archiveClassifier.set('alt')
    from             "$buildDir/alt-classes"
}

task alt {
    group       = 'build'
    description = 'Build alternative JAR.'
    dependsOn   altJar
}

// ------------------------------------------------------------------
// 9) report – при успешных тестах коммитим JUnit-XML в Git
// ------------------------------------------------------------------
ext.testOutcome = null

test {
    afterSuite { desc, result ->
        if (!desc.parent) testOutcome = result
    }
}

task report {
    group       = 'reporting'
    description = 'Commit JUnit XML when tests succeed.'
    dependsOn   test
    doLast {
        if (testOutcome?.resultType
            == org.gradle.api.tasks.testing.TestResult.ResultType.SUCCESS) {
            exec { commandLine 'git', 'add', 'build/test-results/**/*.xml' }
            exec { commandLine 'git', 'commit', '-m', 'Add JUnit report' }
            println 'JUnit report committed.'
        } else {
            println 'Tests failed; skip report commit.'
        }
    }
}

// ------------------------------------------------------------------
// 10) diff – автокоммит если изменение не затрагивает “diffIgnore”
// ------------------------------------------------------------------
task diff {
    group       = 'version control'
    description = 'Auto-commit non-class changes if allowed.'
    doLast {
        def out = new ByteArrayOutputStream()
        exec {
            commandLine    'git', 'status', '--porcelain'
            standardOutput = out
        }
        def ok = true
        out.toString().split('\n').each { line ->
            def path = line.substring(3)
            diffIgnoreClasses.each { pat ->
                if (path.contains(pat)) ok = false
            }
        }
        if (ok) {
            exec { commandLine 'git', 'add', '.' }
            exec { commandLine 'git', 'commit', '-m', 'Auto-commit changes' }
            println 'Changes committed.'
        } else {
            println 'Prohibited class changes detected; no commit.'
        }
    }
}

// ---------------------------------------------------------------------------
// 11) history – откатываемся по rev, пока не соберётся, сохраняем diff в файл
// ---------------------------------------------------------------------------
task history {
  group       = 'version control'
  description = 'Rollback until build succeeds and save diff.'
  doLast {
    // 1) get all revisions
    def revsOut = new ByteArrayOutputStream()
    exec {
      commandLine 'git', 'rev-list', 'HEAD'
      standardOutput = revsOut
    }
    // 2) convert to List<String>
    def revs = revsOut.toString()
                      .trim()
                      .tokenize('\n')   // <-- now revs is a List<String>

    def lastWorking = null

    // 3) find the first rev that builds
    for (rev in revs) {
      exec { commandLine 'git', 'checkout', rev }
      def exitCode = exec {
        ignoreExitValue = true
        commandLine      './gradlew', 'clean', 'build', '-x', 'history'
      }.exitValue
      if (exitCode == 0) {
        lastWorking = rev
        break
      }
    }

    if (lastWorking) {
      println "Last working revision: $lastWorking"
      def idx = revs.indexOf(lastWorking)
      // next rev is the one after lastWorking in the list
      if (idx < revs.size() - 1) {
        def nextRev = revs[idx + 1]
        def diffOut = new ByteArrayOutputStream()
        exec {
          commandLine    'git', 'diff', lastWorking, nextRev
          standardOutput = diffOut
        }
        file("$buildDir/history_diff.txt").text = diffOut.toString()
        println "History diff saved to: build/history_diff.txt"
      } else {
        println "No newer revision to diff against."
      }
    } else {
      println "No working revision found in history."
    }

    exec { commandLine 'git', 'checkout', 'main' }
  }
}
